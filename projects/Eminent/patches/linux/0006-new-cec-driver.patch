From ea4d09bcb15a88937cd79647cd9ac8cf70303346 Mon Sep 17 00:00:00 2001
From: john <john@doe.com>
Date: Sun, 23 Oct 2016 17:50:14 +0300
Subject: [PATCH] new cec driver

---
 arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c |    6 +-
 drivers/amlogic/hdmi/Kconfig                      |    8 +
 drivers/amlogic/hdmi/hdmi_tx/Makefile             |    8 +-
 drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c        |  623 +++++++++++++++++++++
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c            |   36 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c        |  172 +++++-
 6 files changed, 825 insertions(+), 28 deletions(-)
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c

diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
index f5d2999..26b1b01 100755
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
@@ -140,7 +140,7 @@ int cec_ll_rx( unsigned char *msg, unsigned char *len)
                        cec_global_info.my_node_index, *len);
         for (i = 0; i < (*len); i++)
         {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[i]);
+            pos += sprintf(msg_log_buf + pos, "%02x:", msg[i]);
         }
         pos += sprintf(msg_log_buf + pos, "\n");
         msg_log_buf[pos] = '\0';
@@ -202,7 +202,7 @@ static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
         pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
         for (n = 0; n < len; n++)
         {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+            pos += sprintf(msg_log_buf + pos, "%02x:", msg[n]);
         }
         pos += sprintf(msg_log_buf + pos, "\n");
 
@@ -289,7 +289,7 @@ int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
         pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
         for (n = 0; n < len; n++)
         {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+            pos += sprintf(msg_log_buf + pos, "%02x:", msg[n]);
         }
         msg_log_buf[pos] = '\0';
         printk("%s\n", msg_log_buf);
diff --git a/drivers/amlogic/hdmi/Kconfig b/drivers/amlogic/hdmi/Kconfig
index 71f6bf8..1bfc289 100755
--- a/drivers/amlogic/hdmi/Kconfig
+++ b/drivers/amlogic/hdmi/Kconfig
@@ -24,4 +24,12 @@ config AML_HDMI_TX_HDCP
                 hdmitx hdcp enable, it should be enalbe if board burned hdmitx hdcp keys
 endif
 
+if AML_HDMI_TX
+config AML_HDMI_TX_NEW_CEC_DRIVER
+        bool "HDMI new CEC driver"
+        default n
+        help
+                hdmitx uses new CEC driver
+endif
+
 endmenu
diff --git a/drivers/amlogic/hdmi/hdmi_tx/Makefile b/drivers/amlogic/hdmi/hdmi_tx/Makefile
index 7a944cd..f74ec1f 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/Makefile
+++ b/drivers/amlogic/hdmi/hdmi_tx/Makefile
@@ -1,5 +1,11 @@
 obj-$(CONFIG_AML_HDMI_TX)		+= hdmitx.o
 
-hdmitx-objs := hdmi_tx.o hdmi_tx_cec.o hdmi_cec_key.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_compliance.o
+hdmitx-objs := hdmi_tx.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_compliance.o
+
+ifdef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
+  hdmitx-objs += amlogic_cec.o
+else
+  hdmitx-objs += hdmi_tx_cec.o hdmi_cec_key.o
+endif
 
 #EXTRA_CFLAGS += -O2
diff --git a/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c b/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
new file mode 100644
index 0000000..825dc77
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
@@ -0,0 +1,623 @@
+/* linux/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
+ *
+ * Copyright (c) 2016 Gerald Dachs
+ *
+ * CEC interface file for Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/atomic.h>
+#include <linux/semaphore.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <mach/hdmi_tx_reg.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+#define CONFIG_TV_DEBUG // for verbose output
+//#undef CONFIG_TV_DEBUG
+
+MODULE_AUTHOR("Gerald Dachs");
+MODULE_DESCRIPTION("Amlogic CEC driver");
+MODULE_LICENSE("GPL");
+
+bool cec_msg_dbg_en = 0;
+
+MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
+module_param(cec_msg_dbg_en, bool, 0664);
+
+#define DRV_NAME "amlogic_cec"
+#ifndef amlogic_cec_log_dbg
+#define amlogic_cec_log_dbg(fmt, ...) \
+    if (cec_msg_dbg_en)       \
+        printk(KERN_INFO "[%s] %s(): " fmt, DRV_NAME, __func__, ##__VA_ARGS__)
+#endif
+
+#define CEC_IOC_MAGIC        'c'
+#define CEC_IOC_SETLADDR     _IOW(CEC_IOC_MAGIC, 0, unsigned int)
+#define CEC_IOC_GETPADDR     _IO(CEC_IOC_MAGIC, 1)
+
+#define VERSION   "0.0.1" /* Driver version number */
+#define CEC_MINOR 243        /* Major 10, Minor 242, /dev/cec */
+
+/* CEC Rx buffer size */
+#define CEC_RX_BUFF_SIZE            16
+/* CEC Tx buffer size */
+#define CEC_TX_BUFF_SIZE            16
+
+static DEFINE_SEMAPHORE(init_mutex);
+
+struct cec_rx_list {
+        u8 buffer[CEC_RX_BUFF_SIZE];
+        unsigned char size;
+        struct list_head list;
+};
+
+struct cec_rx_struct {
+        spinlock_t lock;
+        wait_queue_head_t waitq;
+        atomic_t state;
+        struct list_head list;
+};
+
+struct cec_tx_struct {
+        spinlock_t lock;
+        wait_queue_head_t waitq;
+        atomic_t state;
+};
+
+enum cec_state {
+        STATE_RX,
+        STATE_TX,
+        STATE_DONE,
+        STATE_ERROR
+};
+
+static char banner[] __initdata =
+    "Amlogic CEC Driver, (c) 2016 Gerald Dachs";
+
+static struct cec_rx_struct cec_rx_struct;
+
+static struct cec_tx_struct cec_tx_struct;
+
+static struct hrtimer cec_late_timer;
+
+static atomic_t hdmi_on = ATOMIC_INIT(0);
+
+cec_global_info_t cec_global_info;
+
+static hdmitx_dev_t* hdmitx_device = NULL;
+
+static void amlogic_cec_set_rx_state(enum cec_state state)
+{
+    atomic_set(&cec_rx_struct.state, state);
+}
+
+static void amlogic_cec_set_tx_state(enum cec_state state)
+{
+    atomic_set(&cec_tx_struct.state, state);
+}
+
+static unsigned int amlogic_cec_read_reg(unsigned int reg)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    return hdmi_rd_reg(CEC0_BASE_ADDR + reg);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    return aocec_rd_reg(reg);
+#endif
+}
+
+static void amlogic_cec_write_reg(unsigned int reg, unsigned int value)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    hdmi_wr_reg(CEC0_BASE_ADDR + reg, value);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    aocec_wr_reg(reg, value);
+#endif
+}
+
+static int amlogic_cec_read_hw()
+{
+    int retval = 0;
+    unsigned long spin_flags;
+    struct cec_rx_list *entry;
+
+    if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+    {
+        amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+        retval = -1;
+    }
+
+    if ((-1) == cec_ll_rx(entry->buffer, &entry->size))
+    {
+        kfree(entry);
+        cec_rx_buf_clear();
+    }
+    else
+    {
+        INIT_LIST_HEAD(&entry->list);
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+        list_add_tail(&entry->list, &cec_rx_struct.list);
+        amlogic_cec_set_rx_state(STATE_DONE);
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+        wake_up_interruptible(&cec_rx_struct.waitq);
+    }
+
+    return retval;
+}
+
+static void amlogic_cec_set_logical_addr(unsigned int logical_addr)
+{
+    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
+    cec_global_info.my_node_index = logical_addr;
+}
+
+unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+{
+    // unused, just to satisfy the linker
+    return log_addr;
+}
+
+static enum hrtimer_restart cec_late_check_rx_buffer(struct hrtimer *timer)
+{
+    if (cec_rx_buf_check())
+    {
+        /*
+         * start another check if rx buffer is full
+         */
+        if ((-1) == amlogic_cec_read_hw())
+        {
+            return HRTIMER_NORESTART;
+        }
+    }
+    if (atomic_read(&hdmi_on))
+    {
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
+    }
+
+    return HRTIMER_NORESTART;
+}
+
+void cec_node_init(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned long cec_phy_addr;
+
+    if (atomic_read(&hdmi_on) && (0 == hdmitx_device->cec_init_ready))
+    {
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+        cec_gpi_init();
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
+        // Clear CEC Int. state and set CEC Int. mask
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+        // GPIOAO_12
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
+        aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 1, 12, 1);       // bit[12]: enable AO_12 internal pull-up   //0xc810002c
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
+        ao_cec_init();
+        cec_arbit_bit_time_set(3, 0x118, 0);
+        cec_arbit_bit_time_set(5, 0x000, 0);
+        cec_arbit_bit_time_set(7, 0x2aa, 0);
+#endif
+        cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
+
+        // If VSDB is not valid,use last or default physical address.
+        if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
+        {
+            amlogic_cec_log_dbg("no valid cec physical address\n");
+            if (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)
+            {
+                amlogic_cec_log_dbg("use last physical address\n");
+            }
+            else
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | 0x1000);
+                amlogic_cec_log_dbg("use default physical address\n");
+            }
+        }
+        else
+        {
+            if ((aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff) != cec_phy_addr)
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | cec_phy_addr);
+                amlogic_cec_log_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
+            }
+        }
+
+        hdmitx_device->cec_init_ready = 1;
+    }
+}
+
+static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
+{
+    unsigned int tx_msg_state;
+    unsigned int rx_msg_state;
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    udelay(100); //Delay execution a little. This fixes an issue when HDMI CEC stops working after a while.
+#endif
+
+    tx_msg_state = amlogic_cec_read_reg(CEC_TX_MSG_STATUS);
+    rx_msg_state = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
+
+    amlogic_cec_log_dbg("cec msg status: rx: 0x%x; tx: 0x%x\n", rx_msg_state, tx_msg_state);
+
+    if ((tx_msg_state == TX_DONE) || (tx_msg_state == TX_ERROR))
+    {
+        switch (tx_msg_state) {
+          case TX_ERROR :
+            amlogic_cec_set_tx_state(STATE_ERROR);
+            break;
+          case TX_DONE :
+            amlogic_cec_set_tx_state(STATE_DONE);
+            break;
+        }
+        wake_up_interruptible(&cec_tx_struct.waitq);
+    }
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (aml_read_reg32(P_AO_CEC_INTR_STAT) & (1<<1))
+    {   // aocec tx intr
+        tx_irq_handle();
+        return IRQ_HANDLED;
+    }
+#endif
+
+    if (rx_msg_state == RX_DONE)
+    {
+        amlogic_cec_read_hw();
+    }
+
+    return IRQ_HANDLED;
+}
+
+static int amlogic_cec_open(struct inode *inode, struct file *file)
+{
+    int ret = 0;
+    unsigned long spin_flags;
+    struct cec_rx_list* entry = NULL;
+
+    if (atomic_read(&hdmi_on))
+    {
+        amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
+        ret = -EBUSY;
+    }
+    else
+    {
+        atomic_inc(&hdmi_on);
+
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+        while(!list_empty(&cec_rx_struct.list))
+        {
+            entry = list_first_entry(&cec_rx_struct.list, struct cec_rx_list, list);
+            list_del(&entry->list);
+            kfree(entry);
+        }
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+        cec_node_init(hdmitx_device);
+
+        cec_enable_irq();
+
+        amlogic_cec_set_logical_addr(0xf);
+
+        if (hdmitx_device->hpd_state != 0)
+        {
+            if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+            {
+                amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+            }
+            else
+            {
+                // let the libCEC ask for new physical Address
+                entry->buffer[0] = 0xff;
+                entry->size = 1;
+                INIT_LIST_HEAD(&entry->list);
+
+                spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+                list_add_tail(&entry->list, &cec_rx_struct.list);
+                amlogic_cec_set_rx_state(STATE_DONE);
+                spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+                amlogic_cec_log_dbg("trigger libCEC\n");
+                wake_up_interruptible(&cec_rx_struct.waitq);
+            }
+        }
+
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
+    }
+    return ret;
+}
+
+static int amlogic_cec_release(struct inode *inode, struct file *file)
+{
+    amlogic_cec_set_logical_addr(0xf);
+
+    cec_disable_irq();
+
+    atomic_dec(&hdmi_on);
+
+    return 0;
+}
+
+static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
+                                size_t count, loff_t *ppos)
+{
+    ssize_t retval;
+    unsigned long spin_flags;
+    struct cec_rx_list* entry = NULL;
+
+    if (wait_event_interruptible(cec_rx_struct.waitq,
+                                 atomic_read(&cec_rx_struct.state) == STATE_DONE))
+    {
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        return -ERESTARTSYS;
+    }
+
+    spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+
+    entry = list_first_entry_or_null(&cec_rx_struct.list, struct cec_rx_list, list);
+
+    if (entry == NULL || entry->size > count)
+    {
+        amlogic_cec_log_dbg("entry is NULL, or empty\n");
+        retval = -1;
+        goto error_exit;
+    }
+
+    if (copy_to_user(buffer, entry->buffer, entry->size))
+    {
+        printk(KERN_ERR " copy_to_user() failed!\n");
+
+        retval = -EFAULT;
+        goto error_exit2;
+    }
+
+    retval = entry->size;
+
+error_exit:
+    if (entry != NULL)
+    {
+            list_del(&entry->list);
+            kfree(entry);
+    }
+
+    if (list_empty(&cec_rx_struct.list))
+    {
+            amlogic_cec_set_rx_state(STATE_RX);
+    }
+
+error_exit2:
+    spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+    return retval;
+}
+
+static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
+                        size_t count, loff_t *ppos)
+{
+    int retval = count;
+    char data[CEC_TX_BUFF_SIZE];
+
+    /* check data size */
+    if (count > CEC_TX_BUFF_SIZE || count == 0)
+        return -1;
+
+    if (copy_from_user(data, buffer, count))
+    {
+        printk(KERN_ERR " copy_from_user() failed!\n");
+        return -EFAULT;
+    }
+
+    amlogic_cec_set_tx_state(STATE_TX);
+
+    // don't write if cec_node_init() is in progress
+    if (down_interruptible(&init_mutex))
+    {
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+        return -ERESTARTSYS;
+    }
+
+    cec_ll_tx(data, count);
+
+    if (wait_event_interruptible_timeout(cec_tx_struct.waitq,
+        atomic_read(&cec_tx_struct.state) != STATE_TX, 2 * HZ) <= 0)
+    {
+        amlogic_cec_log_dbg("error during wait on state change, resetting\n");
+        printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+        cec_hw_reset();
+        retval = -ERESTARTSYS;
+        goto error_exit;
+    }
+
+    if (atomic_read(&cec_tx_struct.state) != STATE_DONE)
+    {
+        printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+        retval = -1;
+    }
+
+error_exit:
+    up(&init_mutex);
+
+    return retval;
+}
+
+static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
+                                                unsigned long arg)
+{
+    unsigned char logical_addr;
+    unsigned int reg;
+
+    switch(cmd) {
+    case CEC_IOC_SETLADDR:
+        if (get_user(logical_addr, (unsigned char __user *)arg))
+        {
+            amlogic_cec_log_dbg("Failed to get logical addr from user\n");
+            return -EFAULT;
+        }
+
+        amlogic_cec_set_logical_addr(logical_addr);
+        /*
+         * use DEBUG_REG1 bit 16 ~ 31 to save logic address.
+         * So uboot can use this logic address directly
+         */
+        reg  = (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
+        reg |= ((unsigned int)logical_addr) << 16;
+        aml_write_reg32(P_AO_DEBUG_REG1, reg);
+
+        amlogic_cec_log_dbg("amlogic_cec_ioctl: Set logical address: %d\n", logical_addr);
+        return 0;
+
+    case CEC_IOC_GETPADDR:
+        amlogic_cec_log_dbg("amlogic_cec_ioctl: return physical address 0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
+            return aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff;
+    }
+
+    return -EINVAL;
+}
+
+static u32 amlogic_cec_poll(struct file *file, poll_table *wait)
+{
+    if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
+    {
+        return POLLIN | POLLRDNORM;
+    }
+
+    poll_wait(file, &cec_rx_struct.waitq, wait);
+
+    if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
+    {
+        return POLLIN | POLLRDNORM;
+    }
+    return 0;
+}
+
+static const struct file_operations cec_fops = {
+    .owner   = THIS_MODULE,
+    .open    = amlogic_cec_open,
+    .release = amlogic_cec_release,
+    .read    = amlogic_cec_read,
+    .write   = amlogic_cec_write,
+    .unlocked_ioctl = amlogic_cec_ioctl,
+    .poll    = amlogic_cec_poll,
+};
+
+static struct miscdevice cec_misc_device = {
+    .minor = CEC_MINOR,
+    .name  = "AmlogicCEC",
+    .fops  = &cec_fops,
+};
+
+static int amlogic_cec_init(void)
+{
+    int retval = 0;
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+
+    if (down_interruptible(&init_mutex))
+    {
+        return -ERESTARTSYS;
+    }
+
+    INIT_LIST_HEAD(&cec_rx_struct.list);
+
+    printk("%s, Version: %s\n", banner, VERSION);
+
+    hdmitx_device = get_hdmitx_device();
+    amlogic_cec_log_dbg("CEC init\n");
+
+    amlogic_cec_set_logical_addr(0xf);
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+#endif
+
+    init_waitqueue_head(&cec_rx_struct.waitq);
+
+    spin_lock_init(&cec_rx_struct.lock);
+
+    init_waitqueue_head(&cec_tx_struct.waitq);
+
+    spin_lock_init(&cec_tx_struct.lock);
+
+    if (misc_register(&cec_misc_device))
+    {
+        printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
+        retval = -EBUSY;
+    }
+
+    hrtimer_init(&cec_late_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    cec_late_timer.function = cec_late_check_rx_buffer;
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (request_irq(INT_HDMI_CEC, &amlogic_cec_irq_handler,
+        IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
+    {
+        amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (request_irq(INT_AO_CEC, &amlogic_cec_irq_handler,
+        IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
+    {
+        amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+
+    // release initial lock on init_mutex
+    up(&init_mutex);
+
+    amlogic_cec_log_dbg("CEC init finished: %d\n", retval);
+
+    return retval;
+}
+
+static void amlogic_cec_exit(void)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+    free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    free_irq(INT_AO_CEC, (void *)hdmitx_device);
+#endif
+    misc_deregister(&cec_misc_device);
+}
+
+module_init(amlogic_cec_init);
+module_exit(amlogic_cec_exit);
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 3e043bc..8443812 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -542,6 +542,7 @@ static ssize_t store_disp_mode(struct device * dev, struct device_attribute *att
     return 16;
 }
 
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 /*cec attr*/
 static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
 {
@@ -589,6 +590,7 @@ static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute
     pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
     return pos;
 }
+#endif
 
 /*aud_mode attr*/
 static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
@@ -963,10 +965,12 @@ static DEVICE_ATTR(disp_cap_3d, S_IWUSR | S_IRUGO, show_disp_cap_3d, NULL);
 static DEVICE_ATTR(hdcp_ksv_info, S_IWUSR | S_IRUGO, show_hdcp_ksv_info, NULL);
 static DEVICE_ATTR(hpd_state, S_IWUSR | S_IRUGO, show_hpd_state, NULL);
 static DEVICE_ATTR(support_3d, S_IWUSR | S_IRUGO, show_support_3d, NULL);
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
 static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_config, store_cec_config);
 //static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
 static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_lang_config, store_cec_lang_config);
+#endif
 
 /*****************************
 *    hdmitx display client interface
@@ -1477,11 +1481,6 @@ static int get_dt_vend_init_data(struct device_node *np, struct vendor_info_data
         return 1;
     }
 
-    ret = of_property_read_u32(np, "cec_config", &(vend->cec_config));
-    if(ret) {
-        hdmi_print(INF, SYS "not find cec config\n");
-        return 1;
-    }
     ret = of_property_read_u32(np, "ao_cec", &(vend->ao_cec));
     if(ret) {
         hdmi_print(INF, SYS "not find ao cec\n");
@@ -1582,7 +1581,9 @@ extern void register_hdmi_is_special_tv_func( int (*pfunc)(void) );
 
 static int amhdmitx_probe(struct platform_device *pdev)
 {
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
     extern struct switch_dev lang_dev;
+#endif
     int r,ret=0;
 
 #ifdef CONFIG_USE_OF
@@ -1643,9 +1644,11 @@ static int amhdmitx_probe(struct platform_device *pdev)
     ret=device_create_file(hdmitx_dev, &dev_attr_hdcp_ksv_info);
     ret=device_create_file(hdmitx_dev, &dev_attr_hpd_state);
     ret=device_create_file(hdmitx_dev, &dev_attr_support_3d);
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
     ret=device_create_file(hdmitx_dev, &dev_attr_cec);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
+#endif
 
     if (hdmitx_dev == NULL) {
         hdmi_print(ERR, SYS "device_create create error\n");
@@ -1732,7 +1735,9 @@ static int amhdmitx_probe(struct platform_device *pdev)
     }
 #endif
     switch_dev_register(&sdev);
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
     switch_dev_register(&lang_dev);
+#endif
 
     hdmitx_init_parameters(&hdmitx_device.hdmi_info);
     HDMITX_Meson_Init(&hdmitx_device);
@@ -1771,8 +1776,9 @@ static int amhdmitx_remove(struct platform_device *pdev)
     device_remove_file(hdmitx_dev, &dev_attr_disp_cap_3d);
     device_remove_file(hdmitx_dev, &dev_attr_hpd_state);
     device_remove_file(hdmitx_dev, &dev_attr_support_3d);
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
     device_remove_file(hdmitx_dev, &dev_attr_cec);
-
+#endif
     cdev_del(&hdmitx_device.cdev);
 
     device_destroy(hdmitx_class, hdmitx_id);
@@ -1830,6 +1836,23 @@ static int amhdmitx_resume(struct platform_device *pdev)
 }
 #endif
 
+static int amhdmitx_shutdown(struct platform_device *pdev,pm_message_t state)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
+        return;
+    hdmitx_device.hpd_lock = 1;
+    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    hdmitx_device.output_blank_flag = 0;
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, DDC_RESET_HDCP);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(IMP, SYS "HDMITX: shutdown\n");
+    return 0;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id meson_amhdmitx_dt_match[]={
     {
@@ -1847,6 +1870,7 @@ static struct platform_driver amhdmitx_driver = {
     .suspend    = amhdmitx_suspend,
     .resume     = amhdmitx_resume,
 #endif
+    .shutdown	= amhdmitx_shutdown,
     .driver     = {
         .name   = DEVICE_NAME,
             .owner    = THIS_MODULE,
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index 42f0a56..ec49f47 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -226,15 +226,6 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
         vend_data = hdmitx_device->config_data.vend_data;
     }
 
-    if ((vend_data) && (vend_data->cec_config))
-    {
-        //hdmitx_device->cec_func_config = vend_data->cec_config;
-        //aml_write_reg32(P_AO_DEBUG_REG0, vend_data->cec_config);
-        //hdmi_print(INF, CEC "cec_func_config: 0x%x; P_AO_DEBUG_REG0:0x%x\n", hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
-    }
-
-    //hdmi_print(INF, CEC "cec_config: 0x%x; ao_cec:0x%x\n", vend_data->cec_config, vend_data->ao_cec);
-
     if ((vend_data) && (vend_data->cec_osd_string))
     {
         i = strlen(vend_data->cec_osd_string);
@@ -348,6 +339,18 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
             cec_device_vendor_id((cec_rx_message_t*)0);
 
             msleep(150);
+
+	    /* Disable switch TV on automatically */
+	    if (!(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))) {
+		cec_usrcmd_get_device_power_status(CEC_TV_ADDR);
+		wait_event_interruptible(hdmitx_device->cec_wait_rx,
+			cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);
+		cec_isr_post_process();
+
+		if (cec_global_info.tv_power_status)
+		    return;
+	    }
+
             cec_imageview_on_smp();
             msleep(100);
 
@@ -363,6 +366,9 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
             cec_active_source_smp();
             msleep(120);
 
+            cec_system_audio_mode_request_smp();
+            msleep(100);
+
             cec_menu_status_smp(DEVICE_MENU_ACTIVE);
             msleep(100);
 
@@ -381,6 +387,11 @@ void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
 {
     if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
        return ;
+
+    cec_inactive_source_smp();
+
+    cec_system_audio_mode_release_smp();
+
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
     hdmi_print(INF, CEC "cec node uninit!\n");
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
@@ -972,6 +983,73 @@ void cec_active_source_smp(void)
     }
     cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
 }
+
+void cec_inactive_source_smp(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[4];
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK))
+        {
+            msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+            msg[1] = CEC_OC_INACTIVE_SOURCE;
+            msg[2] = phy_addr_ab;
+            msg[3] = phy_addr_cd;
+            cec_ll_tx(msg, 4);
+        }
+    }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_system_audio_mode_request_smp(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << SYSTEM_AUDIO_MASK))
+        {
+            if (cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF)
+            {
+                MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                        CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                        phy_addr_ab,
+                        phy_addr_cd
+                );
+                cec_ll_tx(gbl_msg, 4);
+                cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+            }
+        }
+    }
+}
+
+void cec_system_audio_mode_release_smp(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << SYSTEM_AUDIO_MASK))
+        {
+            if (cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
+            {
+                MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                        CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+						0, 0	// physical address of TV
+                );
+                cec_ll_tx(gbl_msg, 4);
+                cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+            }
+        }
+    }
+}
+
 void cec_active_source(cec_rx_message_t* pcec_message)
 {
     unsigned char msg[4];
@@ -1118,7 +1196,7 @@ void cec_give_deck_status(cec_rx_message_t* pcec_message)
 
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_DECK_STATUS;
-    msg[2] = 0x1a;
+    msg[2] = 0x20;
     cec_ll_tx(msg, 3);
 }
 
@@ -1260,6 +1338,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             case CEC_OC_REPORT_PHYSICAL_ADDRESS:
                 break;
             case CEC_OC_REPORT_POWER_STATUS:
+	    cec_global_info.tv_power_status = pcec_message->content.msg.operands[0];
                 break;
             case CEC_OC_SET_OSD_NAME:
                 break;
@@ -1350,6 +1429,15 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
                         break;
                 }
                 break;
+            case CEC_OC_VENDOR_COMMAND:
+                if (pcec_message->content.msg.operands[0] == 0x1) {
+                    cec_report_power_status(pcec_message);
+                    cec_send_simplink_alive(pcec_message);
+                } else if (pcec_message->content.msg.operands[0]
+                                == 0x4) {
+                    cec_send_simplink_ack(pcec_message);
+                }
+                break;
             case CEC_OC_GET_MENU_LANGUAGE:
             case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
             case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
@@ -1369,7 +1457,6 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             case CEC_OC_TUNER_DEVICE_STATUS:
             case CEC_OC_TUNER_STEP_DECREMENT:
             case CEC_OC_TUNER_STEP_INCREMENT:
-            case CEC_OC_VENDOR_COMMAND:
             case CEC_OC_SELECT_ANALOGUE_SERVICE:
             case CEC_OC_SELECT_DIGITAL_SERVICE:
             case CEC_OC_SET_ANALOGUE_TIMER :
@@ -1698,6 +1785,31 @@ void cec_usrcmd_device_menu_control(unsigned char log_addr, unsigned char button
     cec_ll_tx(gbl_msg, 2);
 }
 
+void cec_send_simplink_alive(cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x2;
+	msg[3] = 0x5;
+
+	cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x5;
+	msg[3] = 0x1;
+
+	cec_ll_tx(msg, 4);
+}
 /***************************** cec middle level code end *****************************/
 
 
@@ -1792,6 +1904,9 @@ static void __exit cec_uninit(void)
     {
         return ;
     }
+
+    cec_node_uninit(hdmitx_device);
+
     hdmi_print(INF, CEC "cec uninit!\n");
     if (cec_global_info.cec_flag.cec_init_flag == 1)
     {
@@ -1883,6 +1998,7 @@ void cec_usrcmd_set_config(const char * buf, size_t count)
         while ( buf[i] != ' ' )
             i ++;
     }
+    hdmi_print(INF, CEC "cec_func_config entry :0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
     value = aml_read_reg32(P_AO_DEBUG_REG0);
     aml_set_reg32_bits(P_AO_DEBUG_REG0, param[0], 0, 32);
     hdmitx_device->cec_func_config = aml_read_reg32(P_AO_DEBUG_REG0);
@@ -1905,19 +2021,36 @@ void cec_usrcmd_set_config(const char * buf, size_t count)
         !hdmitx_device->hpd_state) {
         return ;
     }
-    if ((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2)))
+    if ((1 == (param[0] & 1)) && ((value & 0x2) != (param[0] & 0x2)))
     {
-        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-    }
-    if ((1 == (param[0] & 1)) && (0x0 == (value & 0x2)) && (0x2 == (param[0] & 0x2)))
-    {
-        cec_active_source_smp();
+        if (0x2 == (param[0] & 0x2))
+        {
+            cec_active_source_smp();
+        }
+        else
+        {
+        	//cec_inactive_source();
+            cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+        }
     }
     if ((0x20 == (param[0] & 0x20)) && (0x0 == (value & 0x20)) )
     {
         cec_get_menu_language_smp();
     }
-    hdmi_print(INF, CEC "cec_func_config:0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
+    if ((1 == (param[0] & 1)) && ((param[0] & 0x40) != (value & 0x40)))
+    {
+        if (0x40 == (param[0] & 0x40))
+        {
+            hdmi_print(INF, CEC "cec_func_config: cec_system_audio_mode_request_smp");
+            cec_system_audio_mode_request_smp();
+        }
+        else
+        {
+            hdmi_print(INF, CEC "cec_func_config: cec_system_audio_mode_release_smp");
+            cec_system_audio_mode_release_smp();
+        }
+    }
+    hdmi_print(INF, CEC "cec_func_config exit:0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
 }
 
 
@@ -2077,6 +2210,9 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         case PING_TV:    //0x1a LA : For TV CEC detected.
             detect_tv_support_cec(param[1]);
             break;
+        case DEVICE_MENU_CONTROL:    //0x1b
+            cec_usrcmd_device_menu_control(param[1], param[2]);
+            break;
         default:
             break;
     }
-- 
1.7.10.4

diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 8443812..6c20b18 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -1867,7 +1867,7 @@ static struct platform_driver amhdmitx_driver = {
     .probe      = amhdmitx_probe,
     .remove     = amhdmitx_remove,
 #ifdef CONFIG_PM
-    .suspend    = amhdmitx_suspend,
+    .suspend    = amhdmitx_shutdown,
     .resume     = amhdmitx_resume,
 #endif
     .shutdown	= amhdmitx_shutdown,
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index e36e272..807c255 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -525,6 +525,7 @@ int remote_hw_reprot_key(struct remote *remote_data)
 			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
 	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
 #ifdef CONFIG_AML_HDMI_TX
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 		extern int rc_long_press_pwr_key;
 		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
 			rc_long_press_pwr_key = 1;
@@ -534,6 +535,7 @@ int remote_hw_reprot_key(struct remote *remote_data)
 			cec_repeat--;
 
 #endif
+#endif
 		if (remote_data->repeat_enable) {
 			repeat_count++;
 			if (remote_data->repeat_tick < jiffies) {
@@ -618,6 +620,7 @@ int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data)
 			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
 	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
 #ifdef CONFIG_AML_HDMI_TX
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 		extern int rc_long_press_pwr_key;
 		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
 			rc_long_press_pwr_key = 1;
@@ -627,6 +630,7 @@ int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data)
 			cec_repeat--;
 
 #endif
+#endif
 		if (remote_data->repeat_enable) {
 			repeat_count++;
 			if (remote_data->repeat_tick < jiffies) {
@@ -700,6 +704,7 @@ int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
 			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
 	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
 #ifdef CONFIG_AML_HDMI_TX
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 		extern int rc_long_press_pwr_key;
 		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
 			rc_long_press_pwr_key = 1;
@@ -709,6 +714,7 @@ int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
 			cec_repeat--;
 
 #endif
+#endif
 		if (remote_data->repeat_enable) {
 			repeat_count++;
 			if (remote_data->repeat_tick < jiffies) {
diff --git a/drivers/amlogic/input/remote/am_remote.c b/drivers/amlogic/input/remote/am_remote.c
index c824efb..01f0bfb 100755
--- a/drivers/amlogic/input/remote/am_remote.c
+++ b/drivers/amlogic/input/remote/am_remote.c
@@ -390,6 +390,7 @@ static inline int remote_hw_reprot_key(struct remote *remote_data)
 		}
 #ifdef CONFIG_AML_HDMI_TX
 #ifdef CONFIG_ARCH_MESON6
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 		//printk("last_scan_code:%x\n", last_scan_code);
 		if((((scan_code >> 16) & 0xff) == 0x1a) && (!cec_repeat)) {
             extern int rc_long_press_pwr_key;
@@ -401,6 +402,7 @@ static inline int remote_hw_reprot_key(struct remote *remote_data)
 		    cec_repeat--;
 #endif
 #endif
+#endif
 		if (remote_data->repeat_enable) {
 			if ((remote_data->repeat_tick < jiffies)&&(repeat_flag == 1)) {
 				remote_send_key(remote_data->input, (scan_code >> 16) & 0xff, 2);
